<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Line Charts</title>

  <!-- SVG Style -->
  <link rel="stylesheet" type="text/css" href="svgStyle.css" media="screen" />
  <script src="svgUtils.js"></script>
</head>

<body>
  <div class="options">
    <button onclick="showBy('byYear')">by Year</button>
    <button onclick="showBy('bySeason')">by Season</button>
    <button onclick="showBy('byGround')">by Ground</button>
    <button onclick="showBy('byPortArea')">by Port Area</button>
    <input type="checkbox" onclick="clickOnlyTarget(event)" checked>Only +500 samplings</input>
  </div>
  <div id="charts-container"></div>

  <script>
    // Create species object
    let speciesData = {};
    let onlyShowTarget = true;

    let url = 'data/trawlingData/trawling_sizes.json';
    //let url = 'data/purseSeineData/ps_sizes.json'
    fetch(url).then(r => r.json()).then(res => {

      // Organize data to make plots easier
      // Sort by species
      res.forEach(item => {
        if (speciesData[item.ScientificName] == undefined)
          speciesData[item.ScientificName] = {
            'rawData': [],
            'byYear': {},
            'bySeason': {},
            'byGround': {},
            'bySize': {},
            'byPortArea': {},
            'svgPath': '',
            'rangeSize': [Infinity, -Infinity],
            'rangeNumInd': [Infinity, -Infinity],

            // Mininum size, Maturity size?
          };
        speciesData[item.ScientificName].rawData.push(item);
        // Species > Size
        if (speciesData[item.ScientificName].bySize[item.Size] == undefined) {
          speciesData[item.ScientificName].bySize[item.Size] = {
            'rawData': [],
            'numInd': 0,
          }
        }
        // bySize
        speciesData[item.ScientificName].bySize[item.Size].rawData.push(item);
        speciesData[item.ScientificName].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
      });


      // Sort by year, season and ground
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];

        // Find X Y ranges per species
        findSizeAndNumIndRanges(specData, sName);

        const categories = ['byYear', 'bySeason', 'byGround', 'byPortArea'];
        const categoriesKeyAttr = ['Year', 'Season', 'FishingGroundType', 'PortArea'];
        // Iterate raw data
        specData.rawData.forEach(item => {
          // Fill data for the different categories
          for (let i = 0; i < categories.length; i++) {
            // Species > Year, Season, Ground...
            fillDataStruct(specData, item, categories[i], categoriesKeyAttr[i]); // fillDataStruct(specData, item, 'byYear', 'Year');
          }
        });
        // Find X Y ranges per species and categories
        for (let i = 0; i < categories.length; i++) {
          Object.keys(specData[categories[i]]).forEach(key => {
            findSizeAndNumIndRanges(specData[categories[i]][key], sName + '>' + categories[i] + '>' + key);
          });
        }
      });


      // Create SVG paths and combintations
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Species > Year > Season
          specYearData.bySeason = {};
          specYearData.rawData.forEach(item => {
            fillDataStruct(specYearData, item, 'bySeason', 'Season');
          });
        });

        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Species > Season > Year
          specSeasonData.byYear = {};
          specSeasonData.rawData.forEach(item => {
            fillDataStruct(specSeasonData, item, 'byYear', 'Year');
          });
        });



      });


      //debugger;
      showBy('byYear');

    });







    // Fill data structure function
    const fillDataStruct = (specData, item, keyClassName, attrName) => {
      if (specData[keyClassName] == undefined) { debugger; }
      if (specData[keyClassName][item[attrName]] == undefined) {
        specData[keyClassName][item[attrName]] = {
          'rawData': [],
          'bySize': {},
          'svgPath': '',
        }
      }
      specData[keyClassName][item[attrName]].rawData.push(item);
      // Species > Year/Season/Ground > Size
      if (specData[keyClassName][item[attrName]].bySize[item.Size] == undefined) {
        specData[keyClassName][item[attrName]].bySize[item.Size] = {
          'rawData': [],
          'numInd': 0,
        }
      }
      specData[keyClassName][item[attrName]].bySize[item.Size].rawData.push(item);
      specData[keyClassName][item[attrName]].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
    };

    // Find ranges of sizes
    const findSizeAndNumIndRanges = (specData, sName) => {
      // Reset
      specData.rangeSize = [Infinity, -Infinity];
      specData.rangeNumInd = [Infinity, -Infinity];
      if (specData.bySize == undefined) { debugger }

      // Find X Y ranges per species
      Object.keys(specData.bySize).forEach(sKey => {
        // Ranges
        specData.rangeSize[0] = Math.min(specData.rangeSize[0], sKey);
        specData.rangeSize[1] = Math.max(specData.rangeSize[1], sKey);
        specData.rangeNumInd[0] = Math.min(specData.rangeNumInd[0], specData.bySize[sKey].numInd);
        specData.rangeNumInd[1] = Math.max(specData.rangeNumInd[1], specData.bySize[sKey].numInd);
      });
      if (specData.rangeNumInd[1] == 0) {
        console.warn('Maximum abundance for ' + sName + ' is zero, but ' + specData.rawData.length + ' entries are present.');
        specData.rangeNumInd[1] = 1;
      }
    }



    // Create and add plots to DOM
    const plotLengthDistribution = (speciesData, keyClassName) => {

      let container = document.getElementById('charts-container');
      container.innerHTML = '';

      let numPlots = Object.keys(speciesData).length;
      const generateRandomColors = function (number) {
        let colors = [];
        for (let i = 0; i < number; i++) {
          colors[i] = "hsla(" + 360 * Math.random() + ',' +
            (25 + 70 * Math.random()) + '%,' +
            (50 + 10 * Math.random()) + '%,' +
            '0.85)'
        }
        return colors
      }
      const colors = generateRandomColors(numPlots);

      for (let i = 0; i < numPlots; i++) {
        let specData = speciesData[Object.keys(speciesData)[i]];
        if (specData.rawData.length < 500 && onlyShowTarget)
          continue;

        let speciesContainer = document.createElement('div');
        speciesContainer.classList.add('species-container');
        // Iterate per key (season, year, ground)


        // Create SVG example
        let htmlEl = createPlotHTMLEl(specData, Object.keys(speciesData)[i], 'Longitude', 'Abundance', colors[i]);

        let htmlMultipleEl = createMultiplePlotHTMLEl(specData, keyClassName, Object.keys(speciesData)[i] + ' > ' + keyClassName, 'Longitude', 'Abundance', colors[i]);

        htmlEl.appendChild(htmlMultipleEl);
        // Add to DOM
        container.appendChild(htmlEl);
      }

    }




    // On click events
    let currentKeyClassName = 'byYear';
    const showBy = function (keyClassName) {
      keyClassName = keyClassName || currentKeyClassName;
      plotLengthDistribution(speciesData, keyClassName);
      currentKeyClassName = keyClassName;
    }
    const clickOnlyTarget = function (e) {
      onlyShowTarget = e.target.checked;
      // Repaint
      plotLengthDistribution(speciesData, currentKeyClassName);
    }
  </script>
</body>

</html>