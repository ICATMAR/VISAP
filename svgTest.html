<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Line Charts</title>
  <style>
    #charts-container {
      display: flex;
      flex-direction: row;
    }

    .species-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .options {
      position: fixed;
      width: 100%;
      background: rgba(35, 156, 254, 0.463);
      display: flex;
      justify-content: center;
      padding: 5px;
      z-index: 1;
    }
  </style>
  <!-- SVG Style -->
  <link rel="stylesheet" type="text/css" href="svgStyle.css" media="screen" />
  <script src="svgUtils.js"></script>
</head>

<body>
  <div class="options">
    <button onclick="showBy('byYear')">by Year</button>
    <button onclick="showBy('bySeason')">by Season</button>
    <button onclick="showBy('byGround')">by Ground</button>
    <button onclick="showBy('byPortArea')">by Port Area</button>
    <input type="checkbox" onclick="changeOnlyTarget(event)" checked>Only +500 samplings</input>
  </div>
  <div id="charts-container"></div>

  <script>
    // Create species object
    let speciesData = {};
    let onlyShowTarget = true;

    let url = 'data/trawlingData/trawling_sizes.json';
    //let url = 'data/purseSeineData/ps_sizes.json'
    fetch(url).then(r => r.json()).then(res => {

      // Organize data to make plots easier
      // Sort by species
      res.forEach(item => {
        if (speciesData[item.ScientificName] == undefined)
          speciesData[item.ScientificName] = {
            'rawData': [],
            'byYear': {},
            'bySeason': {},
            'byGround': {},
            'bySize': {},
            'byPortArea': {},
            'svgPath': '',
            'rangeSize': [Infinity, -Infinity],
            'rangeNumInd': [Infinity, -Infinity],

            // Mininum size, Maturity size?
          };
        speciesData[item.ScientificName].rawData.push(item);
        // Species > Size
        if (speciesData[item.ScientificName].bySize[item.Size] == undefined) {
          speciesData[item.ScientificName].bySize[item.Size] = {
            'rawData': [],
            'numInd': 0,
          }
        }
        // bySize
        speciesData[item.ScientificName].bySize[item.Size].rawData.push(item);
        speciesData[item.ScientificName].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
      });


      // Sort by year, season and ground
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];

        // Find X Y ranges per specie
        Object.keys(specData.bySize).forEach(sKey => {
          // Ranges
          specData.rangeSize[0] = Math.min(specData.rangeSize[0], sKey);
          specData.rangeSize[1] = Math.max(specData.rangeSize[1], sKey);
          specData.rangeNumInd[0] = Math.min(specData.rangeNumInd[0], specData.bySize[sKey].numInd);
          specData.rangeNumInd[1] = Math.max(specData.rangeNumInd[1], specData.bySize[sKey].numInd);
        });
        // SVG path
        specData.svgPath = generateSVGPath(specData.bySize, specData.rangeSize, specData.rangeNumInd);


        // Iterate raw data
        specData.rawData.forEach(item => {

          // Species > Year
          fillDataStruct(specData, item, 'byYear', 'Year');

          // Species > Season
          fillDataStruct(specData, item, 'bySeason', 'Season');

          // Species > Ground
          fillDataStruct(specData, item, 'byGround', 'FishingGroundType');

          // Species > PortArea
          fillDataStruct(specData, item, 'byPortArea', 'PortArea');

        });
      });


      // Create SVG paths and combintations
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Yearly SVG path
          specYearData.svgPath = generateSVGPath(specYearData.bySize, specData.rangeSize, specData.rangeNumInd)
          // Species > Year > Season
          specYearData.bySeason = {};
          specYearData.rawData.forEach(item => {
            fillDataStruct(specYearData, item, 'bySeason', 'Season');
          });
        });

        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Season SVG path
          specSeasonData.svgPath = generateSVGPath(specSeasonData.bySize, specData.rangeSize, specData.rangeNumInd)
          // Species > Season > Year
          specSeasonData.byYear = {};
          specSeasonData.rawData.forEach(item => {
            fillDataStruct(specSeasonData, item, 'byYear', 'Year');
          });
        });

        // Ground
        Object.keys(specData.byGround).forEach(ground => {
          let specGroundData = specData.byGround[ground];
          // Ground SVG path
          specGroundData.svgPath = generateSVGPath(specGroundData.bySize, specData.rangeSize, specData.rangeNumInd)
        });
        // Port area
        Object.keys(specData.byPortArea).forEach(portArea => {
          let specPortAreaData = specData.byPortArea[portArea];
          // Ground SVG path
          specPortAreaData.svgPath = generateSVGPath(specPortAreaData.bySize, specData.rangeSize, specData.rangeNumInd)
        });



        // Generate remaining SVG paths
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Year > Season
          Object.keys(specYearData.bySeason).forEach(season => {
            let specYearSeasonData = specYearData.bySeason[season];
            // Year > Season SVG path
            specYearSeasonData.svgPath = generateSVGPath(specYearSeasonData.bySize, specData.rangeSize, specData.rangeNumInd)
          });
        });
        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Season > Year
          Object.keys(specSeasonData.byYear).forEach(year => {
            let specSeasonYearData = specSeasonData.byYear[year];
            // Season > Year SVG path
            specSeasonYearData.svgPath = generateSVGPath(specSeasonYearData.bySize, specData.rangeSize, specData.rangeNumInd)
          });
        });

      });


      //debugger;

    });







    // Fill data structure function
    const fillDataStruct = (specData, item, keyClassName, attrName) => {
      if (specData[keyClassName] == undefined) { debugger; }
      if (specData[keyClassName][item[attrName]] == undefined) {
        specData[keyClassName][item[attrName]] = {
          'rawData': [],
          'bySize': {},
          'svgPath': '',
        }
      }
      specData[keyClassName][item[attrName]].rawData.push(item);
      // Species > Year/Season/Ground > Size
      if (specData[keyClassName][item[attrName]].bySize[item.Size] == undefined) {
        specData[keyClassName][item[attrName]].bySize[item.Size] = {
          'rawData': [],
          'numInd': 0,
        }
      }
      specData[keyClassName][item[attrName]].bySize[item.Size].rawData.push(item);
      specData[keyClassName][item[attrName]].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
    };



    // Create and add plots to DOM
    const plotLengthDistribution = (speciesData, keyClassName) => {

      let container = document.getElementById('charts-container');
      container.innerHTML = '';

      let numPlots = Object.keys(speciesData).length;
      const generateRandomColors = function (number) {
        let colors = [];
        for (let i = 0; i < number; i++) {
          colors[i] = "hsla(" + 360 * Math.random() + ',' +
            (25 + 70 * Math.random()) + '%,' +
            (50 + 10 * Math.random()) + '%,' +
            '0.85)'
        }
        return colors
      }
      const colors = generateRandomColors(numPlots);

      for (let i = 0; i < numPlots; i++) {
        let specData = speciesData[Object.keys(speciesData)[i]];
        if (specData.rawData.length < 500)
          continue;

        let speciesContainer = document.createElement('div');
        speciesContainer.classList.add('species-container');
        // Iterate per key (season, year, ground)


        // Create SVG example
        let htmlEl = createPlotHTMLEl(specData, Object.keys(speciesData)[i], 'Longitude', 'Abundance', colors[i]);

        //htmlEl.appendChild(speciesContainer);

        let htmlMultipleEl = createMultiplePlotHTMLEl(specData, keyClassName, Object.keys(speciesData)[i] + ' > ' + keyClassName, 'Longitude', 'Abundance', colors[i]);

        htmlEl.appendChild(htmlMultipleEl);
        // Add to DOM
        container.appendChild(htmlEl);
      }

    }




    // On click events
    let currentKeyClassName = '';
    const showBy = function (keyClassName) {
      keyClassName = keyClassName || currentKeyClassName;
      plotLengthDistribution(speciesData, keyClassName);
      currentKeyClassName = keyClassName;
    }
    const clickOnlyTarget = function (e) {
      onlyShowTarget = e.target.checked;
      // Repaint
      plotLengthDistribution(speciesData);
    }
  </script>
</body>

</html>