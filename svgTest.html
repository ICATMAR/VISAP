<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Line Charts</title>
  <style>
    .chart {
      border: 1px solid #ccc;
      margin-bottom: 20px;
    }

    .axis {
      stroke: #333;
    }

    .line {
      fill: none;
      stroke-width: 2;
    }

    .path {
      fill: rgba(255, 0, 0, 0.459);
      stroke-width: 0.01;
      stroke: black;
      transform: translateY(1px) scaleY(-1);

    }

    #charts-container {
      display: flex;
      flex-direction: row;
    }

    .species-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
  </style>
</head>

<body>
  <div class="options">
    <button onclick="showBy('byYear')">by Year</button>
    <button onclick="showBy('bySeason')">by Season</button>
    <button onclick="showBy('byGround')">by Ground</button>
  </div>
  <div id="charts-container"></div>

  <script>
    // Fill data structure function
    const fillDataStruct = (specData, item, keyClassName, attrName) => {
      if (specData[keyClassName] == undefined) { debugger; }
      if (specData[keyClassName][item[attrName]] == undefined) {
        specData[keyClassName][item[attrName]] = {
          'rawData': [],
          'bySize': {},
          //'byYear': {},
          //'bySeason': {},
          //'byGround': {},
          'svgPath': '',
        }
      }
      specData[keyClassName][item[attrName]].rawData.push(item);
      // Species > Year/Season/Ground > Size
      if (specData[keyClassName][item[attrName]].bySize[item.Size] == undefined) {
        specData[keyClassName][item[attrName]].bySize[item.Size] = {
          'rawData': [],
          'numInd': 0,
        }
      }
      specData[keyClassName][item[attrName]].bySize[item.Size].rawData.push(item);
      specData[keyClassName][item[attrName]].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
    };
    // Create species object
    let speciesData = {};

    let url = 'data/trawlingData/trawling_sizes.json';
    //let url = 'data/purseSeineData/ps_sizes.json'
    fetch(url).then(r => r.json()).then(res => {

      // Organize data to make plots easier
      // Sort by species
      res.forEach(item => {
        if (speciesData[item.ScientificName] == undefined)
          speciesData[item.ScientificName] = {
            'rawData': [],
            'byYear': {},
            'bySeason': {},
            'byGround': {},
            'bySize': {},
            'svgPath': '',
            'rangeSize': [Infinity, -Infinity],
            'rangeNumInd': [Infinity, -Infinity],

            // Mininum size, Maturity size?
          };
        speciesData[item.ScientificName].rawData.push(item);
        // Species > Size
        if (speciesData[item.ScientificName].bySize[item.Size] == undefined) {
          speciesData[item.ScientificName].bySize[item.Size] = {
            'rawData': [],
            'numInd': 0,
          }
        }
        // bySize
        speciesData[item.ScientificName].bySize[item.Size].rawData.push(item);
        speciesData[item.ScientificName].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
      });


      // Sort by year, season and ground
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];

        // Find X Y ranges per specie
        Object.keys(specData.bySize).forEach(sKey => {
          // Ranges
          specData.rangeSize[0] = Math.min(specData.rangeSize[0], sKey);
          specData.rangeSize[1] = Math.max(specData.rangeSize[1], sKey);
          specData.rangeNumInd[0] = Math.min(specData.rangeNumInd[0], specData.bySize[sKey].numInd);
          specData.rangeNumInd[1] = Math.max(specData.rangeNumInd[1], specData.bySize[sKey].numInd);
        });
        // SVG path
        specData.svgPath = generateSVGPath(specData.bySize, specData.rangeSize, specData.rangeNumInd);



        // Iterate raw data
        specData.rawData.forEach(item => {

          // Species > Year
          fillDataStruct(specData, item, 'byYear', 'Year');

          // Species > Season
          fillDataStruct(specData, item, 'bySeason', 'Season');

          // Species > Ground
          fillDataStruct(specData, item, 'byGround', 'FishingGroundType');

        });
      });


      // By Year combined with Season and viceversa
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Yearly SVG path
          specYearData.svgPath = generateSVGPath(specYearData.bySize, specData.rangeSize, specData.rangeNumInd)
          // Species > Year > Season
          specYearData.bySeason = {};
          specYearData.rawData.forEach(item => {
            fillDataStruct(specYearData, item, 'bySeason', 'Season');
          });
        });

        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Season SVG path
          specSeasonData.svgPath = generateSVGPath(specSeasonData.bySize, specData.rangeSize, specData.rangeNumInd)
          // Species > Season > Year
          specSeasonData.byYear = {};
          specSeasonData.rawData.forEach(item => {
            fillDataStruct(specSeasonData, item, 'byYear', 'Year');
          });
        });

        // Generate remaining SVG paths
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Year > Season
          Object.keys(specYearData.bySeason).forEach(season => {
            let specYearSeasonData = specYearData.bySeason[season];
            // Year > Season SVG path
            specYearSeasonData.svgPath = generateSVGPath(specYearSeasonData.bySize, specData.rangeSize, specData.rangeNumInd)
          });
        });
        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Season > Year
          Object.keys(specSeasonData.byYear).forEach(year => {
            let specSeasonYearData = specSeasonData.byYear[year];
            // Season > Year SVG path
            specSeasonYearData.svgPath = generateSVGPath(specSeasonYearData.bySize, specData.rangeSize, specData.rangeNumInd)
          });
        });

      });









      //debugger;

      let numPlots = Object.keys(speciesData).length;
      const generateRandomColors = function (number) {
        let colors = [];
        for (let i = 0; i < number; i++) {
          colors[i] = "hsla(" + 360 * Math.random() + ',' +
            (25 + 70 * Math.random()) + '%,' +
            (50 + 10 * Math.random()) + '%,' +
            '0.85)'
        }
        return colors
      }
      const colors = generateRandomColors(numPlots);

      let container = document.getElementById('charts-container');
      container.innerHTML = '';

      for (let i = 0; i < numPlots; i++) {
        let specData = speciesData[Object.keys(speciesData)[i]];

        let speciesContainer = document.createElement('div');
        speciesContainer.classList.add('species-container');
        // Iterate per year
        Object.keys(specData.byYear).forEach(year => {

          // Create SVG example
          //let specData = speciesData['Abralia veranyi']
          let svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svgEl.setAttribute('width', '200');
          svgEl.setAttribute('height', '200');
          svgEl.setAttribute('viewBox', '0 0 1 1');
          svgEl.style['margin-top'] = '-120px';
          svgEl.style['border-bottom'] = '#0000004d solid';

          // Create the path element
          let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', specData.byYear[year].svgPath);
          path.setAttribute('stroke-linejoin', 'round');
          path.classList.add('path');
          path.style.stroke = colors[i];
          path.style.fill = colors[i].replace('0.85)', '0.4)');

          // Append the path to the SVG
          svgEl.appendChild(path);

          // Append the SVG to the document body or any other container
          speciesContainer.appendChild(svgEl);
          // Year
          let elYear = document.createElement('div');
          elYear.innerText = year;
          speciesContainer.appendChild(elYear);

        });
        // Create SVG example
        //let specData = speciesData['Abralia veranyi']
        let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '200');
        svg.setAttribute('height', '200');
        svg.setAttribute('viewBox', '0 0 1 1');

        // Create the path element
        let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', specData.svgPath);
        path.setAttribute('stroke-linejoin', 'round');
        path.classList.add('path');
        path.style.stroke = colors[i];
        path.style.fill = colors[i].replace('0.85)', '0.4)');

        // Append the path to the SVG
        svg.appendChild(path);

        // Append the SVG to the document body or any other container
        speciesContainer.appendChild(svg);

        // Append species name
        let specName = document.createElement('h2');
        specName.innerText = Object.keys(speciesData)[i];
        speciesContainer.appendChild(specName)

        // Add to DOM
        container.appendChild(speciesContainer);
      }
    });



    // Generate SVG path
    const generateSVGPath = function (sizes, rangeSize, rangeNumInd) {
      let path = '';
      rangeSize = [...rangeSize]; // Copy
      rangeNumInd = [...rangeNumInd]; // Copy
      rangeSize[1] *= 1.1;
      rangeNumInd[1] *= 1.1;

      let sizesKeys = Object.keys(sizes);
      // If there is no data
      if (sizesKeys[1] == undefined) {
        let xPos = sizesKeys[0] / rangeSize[1];
        return 'M ' + (xPos - 0.01) + ' 0 L ' + xPos + ' ' + sizes[sizesKeys[0]].numInd / rangeNumInd[1] + ' L ' + (xPos + 0.01) + ' 0'; // One peak
      }
      // First two points
      let step = sizesKeys[0] - (sizesKeys[1] - sizesKeys[0]);
      if (isNaN(step / rangeSize[1])) { debugger; }
      path += 'M 0 0 L ' + step / rangeSize[1] + ' 0 ';
      // Data points
      for (const sKey of sizesKeys) {
        path += 'L ' + sKey / rangeSize[1] + ' ' + sizes[sKey].numInd / rangeNumInd[1] + ' ';
        if (sizes[sKey].numInd / rangeNumInd[1] > 1) { debugger }
      }
      // End point
      path += 'L 1 0';

      return path;
    }


  </script>
</body>

</html>