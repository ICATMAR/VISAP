<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Line Charts</title>
  <style>
    .chart {
      border: 1px solid #ccc;
      margin-bottom: 20px;
    }

    .axis {
      stroke: #333;
    }

    .line {
      fill: none;
      stroke-width: 2;
    }

    .path {
      fill: rgba(255, 0, 0, 0.459);
      stroke-width: 0.01;
      stroke: black;
      transform: translateY(1px) scaleY(-1);

    }

    #charts-container {
      display: flex;
      flex-direction: row;
    }
    .yearly-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .translate {
      transform: translate(40px, 20px);
      /* Translate axes and line charts */
    }
  </style>
</head>

<body>
  <div id="charts-container"></div>

  <script>

    let url = 'data/trawlingData/trawling_sizes.json';
    //let url = 'data/purseSeineData/ps_sizes.json'
    fetch(url).then(r => r.json()).then(res => {

      // Organize data to make plots easier
      // Create species object
      let speciesData = {};
      // Sort by species
      res.forEach(item => {
        if (speciesData[item.ScientificName] == undefined)
          speciesData[item.ScientificName] = {
            'rawData': [],
            'byYear': {},
            'bySeason': {},
            'bySize': {},
            'svgPath': '',
            'rangeSize': [Infinity, -Infinity],
            'rangeNumInd': [Infinity, -Infinity],

            // Mininum size, Maturity size?
          };
        speciesData[item.ScientificName].rawData.push(item);
        // Species > Size
        if (speciesData[item.ScientificName].bySize[item.Size] == undefined) {
          speciesData[item.ScientificName].bySize[item.Size] = {
            'rawData': [],
            'numInd': 0,
          }
        }
        // bySize
        speciesData[item.ScientificName].bySize[item.Size].rawData.push(item);
        speciesData[item.ScientificName].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
      });


      // Sort by year
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];

        // Find X Y ranges per specie
        Object.keys(specData.bySize).forEach(sKey => {
          // Ranges
          specData.rangeSize[0] = Math.min(specData.rangeSize[0], sKey);
          specData.rangeSize[1] = Math.max(specData.rangeSize[1], sKey);
          specData.rangeNumInd[0] = Math.min(specData.rangeNumInd[0], specData.bySize[sKey].numInd);
          specData.rangeNumInd[1] = Math.max(specData.rangeNumInd[1], specData.bySize[sKey].numInd);
        });
        // SVG path
        specData.svgPath = generateSVGPath(specData.bySize, specData.rangeSize, specData.rangeNumInd);



        // Iterate raw data
        specData.rawData.forEach(item => {

          // Species > Year
          if (specData.byYear[item.Year] == undefined) {
            specData.byYear[item.Year] = {
              'rawData': [],
              'bySize': {},
              'bySeason': {},
              'svgPath': '',
            }
          }
          specData.byYear[item.Year].rawData.push(item);
          // Species > Year > Size
          if (specData.byYear[item.Year].bySize[item.Size] == undefined) {
            specData.byYear[item.Year].bySize[item.Size] = {
              'rawData': [],
              'numInd': 0,
            }
          }
          specData.byYear[item.Year].bySize[item.Size].rawData.push(item);
          specData.byYear[item.Year].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);


          // Species > Season
          if (specData.bySeason[item.Season] == undefined) {
            specData.bySeason[item.Season] = {
              'rawData': [],
              'bySize': {},
              'byYear': {},
              'svgPath': '',
            }
          }
          specData.bySeason[item.Season].rawData.push(item);
          // Species > Season > Size
          if (specData.bySeason[item.Season].bySize[item.Size] == undefined) {
            specData.bySeason[item.Season].bySize[item.Size] = {
              'rawData': [],
              'numInd': 0,
            }
          }
          specData.bySeason[item.Season].bySize[item.Size].rawData.push(item);
          specData.bySeason[item.Season].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
        });
      });


      // By Year combined with Season and viceversa
      Object.keys(speciesData).forEach(sName => {
        let specData = speciesData[sName];
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Yearly SVG path
          specYearData.svgPath = generateSVGPath(specYearData.bySize, specData.rangeSize, specData.rangeNumInd)
          // Species > Year > Season
          specYearData.rawData.forEach(item => {
            if (specYearData.bySeason[item.Season] == undefined) {
              specYearData.bySeason[item.Season] = {
                'rawData': [],
                'bySize': {},
                'svgPath': '',
              }
            }
            specYearData.bySeason[item.Season].rawData.push(item);
            // Species > Year > Season > Size
            if (specYearData.bySeason[item.Season].bySize[item.Size] == undefined) {
              specYearData.bySeason[item.Season].bySize[item.Size] = {
                'rawData': [],
                'numInd': 0,
              }
            }
            specYearData.bySeason[item.Season].bySize[item.Size].rawData.push(item);
            specYearData.bySeason[item.Season].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
          });
        });

        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Season SVG path
          specSeasonData.svgPath = generateSVGPath(specSeasonData.bySize, specData.rangeSize, specData.rangeNumInd)
          // Species > Season > Year
          specSeasonData.rawData.forEach(item => {
            if (specSeasonData.byYear[item.Year] == undefined) {
              specSeasonData.byYear[item.Year] = {
                'rawData': [],
                'bySize': {},
                'svgPath': '',
              }
            }
            specSeasonData.byYear[item.Year].rawData.push(item);
            // Species > Season > Year > Size
            if (specSeasonData.byYear[item.Year].bySize[item.Size] == undefined) {
              specSeasonData.byYear[item.Year].bySize[item.Size] = {
                'rawData': [],
                'numInd': 0,
              }
            }
            specSeasonData.byYear[item.Year].bySize[item.Size].rawData.push(item);
            specSeasonData.byYear[item.Year].bySize[item.Size].numInd += parseFloat(item.Abundance_NSpecimen_Km2 || item.Abundance_NSpecimen);
          });
        });


        // Generate remaining SVG paths
        // Year
        Object.keys(specData.byYear).forEach(year => {
          let specYearData = specData.byYear[year];
          // Year > Season
          Object.keys(specYearData.bySeason).forEach(season => {
            let specYearSeasonData = specYearData.bySeason[season];
            // Year > Season SVG path
            specYearSeasonData.svgPath = generateSVGPath(specYearSeasonData.bySize, specData.rangeSize, specData.rangeNumInd)
          });
        });
        // Season
        Object.keys(specData.bySeason).forEach(season => {
          let specSeasonData = specData.bySeason[season];
          // Season > Year
          Object.keys(specSeasonData.byYear).forEach(year => {
            let specSeasonYearData = specSeasonData.byYear[year];
            // Season > Year SVG path
            specSeasonYearData.svgPath = generateSVGPath(specSeasonYearData.bySize, specData.rangeSize, specData.rangeNumInd)
          });
        });
      });



      //debugger;

      let numPlots = Object.keys(speciesData).length;
      const generateRandomColors = function (number) {
        let colors = [];
        for (let i = 0; i < number; i++) {
          colors[i] = "hsla(" + 360 * Math.random() + ',' +
            (25 + 70 * Math.random()) + '%,' +
            (50 + 10 * Math.random()) + '%,' +
            '0.85)'
        }
        return colors
      }
      const colors = generateRandomColors(numPlots);

      let container = document.getElementById('charts-container');

      for (let i = 0; i < numPlots; i++) {
        let specData = speciesData[Object.keys(speciesData)[i]];

        let yearlyContainer = document.createElement('div');
        yearlyContainer.classList.add('yearly-container');
        // Iterate per year
        Object.keys(specData.byYear).forEach(year => {

          // Create SVG example
          //let specData = speciesData['Abralia veranyi']
          let svgYear = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
          svgYear.setAttribute('width', '200');
          svgYear.setAttribute('height', '200');
          svgYear.setAttribute('viewBox', '0 0 1 1');
          svgYear.style['margin-top'] = '-120px';
          svgYear.style['border-bottom'] = '#0000004d solid';

          // Create the path element
          let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', specData.byYear[year].svgPath);
          path.setAttribute('stroke-linejoin', 'round');
          path.classList.add('path');
          path.style.stroke = colors[i];
          path.style.fill = colors[i].replace('0.85)', '0.4)');

          // Append the path to the SVG
          svgYear.appendChild(path);

          // Append the SVG to the document body or any other container
          yearlyContainer.appendChild(svgYear);
          // Year
          let elYear = document.createElement('div');
          elYear.innerText = year;
          yearlyContainer.appendChild(elYear);

        });
        // Create SVG example
        //let specData = speciesData['Abralia veranyi']
        let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '200');
        svg.setAttribute('height', '200');
        svg.setAttribute('viewBox', '0 0 1 1');

        // Create the path element
        let path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', specData.svgPath);
        path.setAttribute('stroke-linejoin', 'round');
        path.classList.add('path');
        path.style.stroke = colors[i];
        path.style.fill = colors[i].replace('0.85)', '0.4)');

        // Append the path to the SVG
        svg.appendChild(path);

        // Append the SVG to the document body or any other container
        yearlyContainer.appendChild(svg);

        // Append species name
        let specName = document.createElement('h2');
        specName.innerText = Object.keys(speciesData)[i];
        yearlyContainer.appendChild(specName)

        // Add to DOM
        container.appendChild(yearlyContainer);
      }
    });



    // Generate SVG path
    const generateSVGPath = function (sizes, rangeSize, rangeNumInd) {
      let path = '';
      let sizesKeys = Object.keys(sizes);
      // If there is no data
      if (sizesKeys[1] == undefined) {
        return 'M 0.49 0 L 0.5 1 L 0.51 0'; // One peak
      }
      // First two points
      let step = sizesKeys[0] - (sizesKeys[1] - sizesKeys[0]);
      if (isNaN(step / rangeSize[1])) { debugger; }
      path += 'M 0 0 L ' + step / rangeSize[1] + ' 0 ';
      // Data points
      for (const sKey of sizesKeys) {
        path += 'L ' + sKey / rangeSize[1] + ' ' + sizes[sKey].numInd / rangeNumInd[1] + ' ';
        if (sizes[sKey].numInd / rangeNumInd[1] > 1) { debugger }
      }
      // End point
      path += 'L 1 0';

      return path;
    }


  </script>
</body>

</html>